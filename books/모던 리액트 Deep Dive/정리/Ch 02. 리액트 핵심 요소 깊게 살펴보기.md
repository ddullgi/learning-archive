# 목차

- 2.1 [JSX](#jsx)

# JSX

JSX는 React의 등장과 함께 페이스북(현 메타)에서 소개된 구문으로, 기본적으로 HTML이나 XML과 같은 구조를 자바스크립트 내부에서 표현하는 데 사용됩니다. 뿐만 아니라, JSX는 이러한 구조를 트랜스파일러를 통해 표준 자바스크립트(ECMAScript)로 변환하는 데 초점을 두고 있으며, React 외의 환경에서도 활용될 수 있습니다.

## JSX의 정의

JSX는 기본적으로 `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성돼 있다.

### JSXElement

JSX를 구성하는 가장 기본 요소로, HTML의 요소(elemnet)와 비슷한 역할을 한다. `JSXElement`가 되기 위해서는 다음과 같은 형태 중 하나여야 한다.

- **JSXOpeningElemnet**:
  - 일반적으로 볼 수 있는 요소이다.
  - `JSXOpeningElemnet`로 시작했다면 `JSXClossingElement`가 같은 depth에 선언돼 있어야 올바른 JSX 문법으로 간주된다.
  - ex) `<JSXElement JSXAttributes(optional)>`
- **JSXClossingElement**:
  - `JSXOpeningElemnet`가 종료됐음을 알리는 요소로, 반드시 `JSXOpeningElemnet`와 쌍으로 사용해야 한다.
  - ex) `</JSXElement>`
- **JSXSelfClosingElement**
  - 요소가 시작되고, 스스로 종료되는 형태를 의미한다.
  - `<script />`와 동일한 모습을 띄고 있다.
  - 이는 내부적으로 자식을 포함할 수 없는 형태를 의미한다.
  - ex) `<JSXElement JSXAttributes(optional) />`
- **JSXFragement**
  - 아무런 요소가 없는 형태로, `JSXSelfClosingElement` 형태를 띌 수는 없다.
  - `</>`는 불가능하다. 단 `<></>` 형태는 가능하다.
  - ex) `<>JSXChildren(optional)</>`

<aside>
💡

**요소명은 대문자로 시작해야만 되는 거 아닌가요?**

- JSXElement 문법에는 명시되어 있지 않은 내용
- React에서는 HTML 구문 이외에 사용자가 컴포넌트를 만들 경우 반드시 대문자로 시작하는 컴포넌트를 만들어야 사용 가능하다.
- React에서 HTML 태그명과 사용자 컴포넌트 태그명을 구분 짓기 위함이다.
- HTML 태그명을 따로 필터링 하지 않는 이유는 HTML의 확장성을 염두하고 있어서이다.
</aside>

### JSXElementName

JSXElementName은 JSXElement의 이름으로 사용가능한 것들을 의미합니다.

- **JSXIndetifier**

  - JSX 내부에서 사용할 수 있는 식별자를 의미한다.
  - 자바스크립트의 식별자 규칙과 동일
  - 숫자로 시작하거나 `$`와 `_`외의 다른 특수 문자로는 시작할 수 없다.
  - 예시

    ```jsx
    function Valid1() {
    	return <$></$>
    }

    function Valid2() {
    	return <_></_>
    }

    // 불가능
    function InValid1() {
    	return <1></1>
    }
    ```

- **JSXNamespacedName(React에선 사용 X)**

  - `JSXIndetifier:JSXIndetifier`의 조합, 즉 `:`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다.
  - `:`로 묶을 수 있는 것은 한 개 뿐이다. 두 개 이상은 올바른 식별자로 취급되지 않는다.
  - 예시

    ```jsx
    function Valid() {
    	return <foo:bar></foo:bar>
    }

    // 불가능
    function InValid() {
    	return <foo:bar:baz></foo:bar:baz>
    }
    ```

- **JSXMemberExpression(React에선 사용 X)**

  - `JSXIndetifier.JSXIndetifier`의 조합, 즉 `.`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다.
  - `:`로 묶는 `JSXNamespacedName`과는 다르게 `.`을 여러 개 이어서 하는 것도 가능하다.
  - 단 `JSXNamespacedName`과 이어서 사용하는 것은 불가능 하다.
  - 예시

    ```jsx
    function Valid1() {
    	return <foo.bar></foo.bar>
    }

    function Valid2() {
    	return <foo.bar.baz></foo.bar.baz>
    }

    // 불가능
    function InValid() {
    	return <foo:bar.baz></foo:bar.baz>
    }
    ```

### JSXAttributes

JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수 값이 아니고, 없다고 에러가 나지 않는다.

- **JSXSpreadAttributes**

  - 자바스크립트의 전개 연산자와 동일한 역할
  - **{…AssignmentExpression}**

    - 이때 `AssignmentExpression`에는 객체뿐만 아니라 조건문 표현식, 화살표 함수, 할당식 등의 모든 표현식이 들어올 수 있습니다.

      ```jsx
      const props = { id: 1, name: "John" };
      const element = <Component {...props} />;

      // 삼항 연산의 결과인 obj를 전개
      const obj = { a: 1 };
      const component = <MyComponent {...(true ? obj : { b: 2 })} />;

      // 함수의 반환 값인 obj를 전개
      const obj = { a: 1 };
      const component = <MyComponent {...(() => obj)()} />;
      ```

- **JSXAttribute**

  - 속성을 나타내는 키와 값으로 짝을 이루어서 표현한다.
  - **JSXAttributeName**
    - 속성의 키 값
    - 키로는 `JSXElementName`에서 언급한 `JSXIdentifier`와 `JSXNamespacedName`이 가능하다.
      ```jsx
      function Valid1() {
        return <foo.bar foo:bar="baz"></foo.bar>;
      }
      ```
  - **JSXAttributeValue**

    - 속성의 키에 할당할 수 있는 값으로, 다음 중 하나에 만족해야 함
    - `“큰따옴표로 구성된 문자열”`: JS문자열과 동일. 내용이 없어도 됨
    - `‘작은따옴표로 구성된 문자열’`: JS문자열과 동일. 내용이 없어도 됨
    - `{ AssignmentExpression }`: `AssignmentExpression`는 JS의 변수에 값으로 넣을 수 있는 모든 표현식을 의미한다.
    - `JSXElement`: 값으로 다른 JSX 요소가 들어갈 수 있다.

      ```jsx
      function Child({ attribute }) {
        return <div>{attribute}</div>;
      }

      export default function App() {
        return (
          <div>
            <Child attribute=<div>hello</div> />
          </div>
        );
      }
      ```

      - 대부분의 React 개발자들은 `<Child attribute={<div>hello</div>} />`와 같이 값으로 들어가는 React component를 `{}`로 감싸는 것이 더 익숙할텐데, 사실 이것은 문법 오류가 아닌 prettier 규칙이다. 이 규칙은 가독성을 더 높이기 위해 제공된다.

    - `JSXFragment`: 값으로 별도 속성을 갖지 않는 형태의 JSX 요소이다. 즉, 비어있는 형태의 `<></>`가 허용된다.

### JSXChildren

JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 한다.

- **JSXChild**
  - JSXChildren을 이루는 기본 단위다.
  - JSXChildren은 JSXChild를 0개 이상 가질 수 있다.
  - 0개를 보면 알 수 있듯 JSXChildren은 JSXChild 가 없어도 된다.
  - `JSXText`
    - `{`, `<`, `>`, `}` 을 제외한 문자열. 이는 다른 JSX문법에 혼동을 줄 수 있기 때문
    - 만약 위 문자를 표현하고 싶다면 따옴표 안에 넣으면 된다.
      ```jsx
      function Vaild() {
        return <>{"{} <>"}</>;
      }
      ```
  - `JSXElement`
    - 값으로 다른 JSX 요소가 들어갈 수 있다.
  - `JSXFragment`
    - 값으로 빈 JSX 요소인 `<></>`가 들어갈 수 있다.
  - `{ JSXChildExpression (optional) }`
    - 이 `JSXChildExpression`는 자바스크립트의 `AssignmentExpression`을 의미한다.
      ```jsx
      // 이 함수를 리액트에서 렌더링하면 "foo"라는 문자열이 출력된다.
      export default function App() {
        return <>{(() => "foo")()}</>;
      }
      ```

### JSXStrings

JSX 문법 내에서 문자열을 처리하는 방법으로 앞서 설명한 `JSXText`와 `JSXAttributeValue`의 따옴표가 이에 포함되며 HTML에서 쓸 수 있는 문자열은 모두 사용가능하다.

주의할 점은 이스케이프 문자 처리에 신경써야 된다.

```jsx
// HTML에서는 \ 문자를 그대로 사용할 수 있다.
<button>\</button>

// JSX에서는 \ 문자를 그대로 사용하면 에러가 발생한다.
return <button>\</button>; // SyntaxError: Unexpected token

// JSX에서 \ 문자를 올바르게 사용하려면 이스케이프 처리를 해야 한다.
return <button>\\</button>; // 올바른 표현

// JavaScript 문자열 내에서 \ 문자를 이스케이프 처리하지 않으면 에러가 발생한다.
let escape1 = "\"; // SyntaxError: Invalid or unexpected token

// \ 문자를 올바르게 이스케이프 처리한 경우
let escape2 = "\\"; // 올바른 표현
```

## JSX는 어떻게 변환되는가

JSX는 `@babel/plugin-transform-react-jsx`를 통해 자바스크립트가 이해할 수 있는 형태로 변환한다.

다음과 같은 JSX 코드가 있다고 가정해보자

```jsx
const ComponentA = <A required={true}>Hello World</A>;

const ComponentB = <>Hello World</>;

const ComponentC = (
  <div>
    <span>hello world</span>
  </div>
);
```

이를 변환한 결과는 다음과 같다.

```jsx
// @babel/plugin-transform-react-jsx로 변환한 결과
"use strict";

var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  "Hello World"
);
var ComponentB = React.createElement(React.Fragment, null, "Hello World");
var ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello world")
);
```

React 17, babel 7.9.0 이후 버전에서 추가된 자동 런타임(automatic runtime)으로 트랜스파일한 결과는 다음과 같다.(두 결과의 자세한 차이점은 8장에서 설명)

```jsx
// 자동 런타임(automatic runtime)으로 변환한 결과
"use strict";

var _jsxRuntime = require("custom-jsx-libray/jsx-runtime");

var ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: "Hello World",
});

var ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: "Hello World",
});

var ComponentC = (0, _jsxRuntime.jsx)("div", {
  children: (0, _jsxRuntime.jsx)("span", {
    children: "hello world",
  }),
});
```

두 결과물에는 약간의 차이가 있지만 다음과 같은 공통점이 있다.

- JSXElement를 첫 번째 인수로 선언해 요소를 정의한다.
- 옵셔널인 `JSXChildren`, `JSXAttributes`, `JSXStrings`는 이후 인수로 넘겨주어 처리한다.

이러한 공통점을 활용한다면 경우에 따라 다른 JSXElement를 렌더링해야할 때 굳이 요소 전체를 감싸지 않아도 처리할 수 있다. 이는 JSXElement만 다르고, `JSXChildren`, `JSXAttributes`이 완전히 동일한 상황에서 중복 코드를 최소화 할 수 있다.

```jsx
// JSX가 변환되는 특성을 이용

// X props 여부에 따라 children 요소만 달라지는 경우
// 굳이 전체 내용을 삼항 연산자로 처리할 필요가 없다.
// 이 경우 불필요한 코드 중복이 일어난다.
function TextOrHeading({ isHeading, children }) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// O JSX가 변환되는 특성을 활용하면 다음과 같이 간결하게 바꿀 수 있다.
import { createElement } from "react";

function TextOrHeading({ isHeading, children }) {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

JSX 반환 값이 결국 `React.createElement`로 귀결된다는 사실을 파악한다면 이런 식으로 쉽게 리팩터링할 수 있다.
