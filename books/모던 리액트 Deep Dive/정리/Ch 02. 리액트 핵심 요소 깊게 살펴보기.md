# 목차

- 2.1 [JSX](#jsx)
- 2.2 [가상 DOM과 리액트 파이버](#가상-dom과-리액트-파이버)

# JSX

JSX는 React의 등장과 함께 페이스북(현 메타)에서 소개된 구문으로, 기본적으로 HTML이나 XML과 같은 구조를 자바스크립트 내부에서 표현하는 데 사용됩니다. 뿐만 아니라, JSX는 이러한 구조를 트랜스파일러를 통해 표준 자바스크립트(ECMAScript)로 변환하는 데 초점을 두고 있으며, React 외의 환경에서도 활용될 수 있습니다.

## JSX의 정의

JSX는 기본적으로 `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성돼 있다.

### JSXElement

JSX를 구성하는 가장 기본 요소로, HTML의 요소(elemnet)와 비슷한 역할을 한다. `JSXElement`가 되기 위해서는 다음과 같은 형태 중 하나여야 한다.

- **JSXOpeningElemnet**:
  - 일반적으로 볼 수 있는 요소이다.
  - `JSXOpeningElemnet`로 시작했다면 `JSXClossingElement`가 같은 depth에 선언돼 있어야 올바른 JSX 문법으로 간주된다.
  - ex) `<JSXElement JSXAttributes(optional)>`
- **JSXClossingElement**:
  - `JSXOpeningElemnet`가 종료됐음을 알리는 요소로, 반드시 `JSXOpeningElemnet`와 쌍으로 사용해야 한다.
  - ex) `</JSXElement>`
- **JSXSelfClosingElement**
  - 요소가 시작되고, 스스로 종료되는 형태를 의미한다.
  - `<script />`와 동일한 모습을 띄고 있다.
  - 이는 내부적으로 자식을 포함할 수 없는 형태를 의미한다.
  - ex) `<JSXElement JSXAttributes(optional) />`
- **JSXFragement**
  - 아무런 요소가 없는 형태로, `JSXSelfClosingElement` 형태를 띌 수는 없다.
  - `</>`는 불가능하다. 단 `<></>` 형태는 가능하다.
  - ex) `<>JSXChildren(optional)</>`

<aside>
💡

**요소명은 대문자로 시작해야만 되는 거 아닌가요?**

- JSXElement 문법에는 명시되어 있지 않은 내용
- React에서는 HTML 구문 이외에 사용자가 컴포넌트를 만들 경우 반드시 대문자로 시작하는 컴포넌트를 만들어야 사용 가능하다.
- React에서 HTML 태그명과 사용자 컴포넌트 태그명을 구분 짓기 위함이다.
- HTML 태그명을 따로 필터링 하지 않는 이유는 HTML의 확장성을 염두하고 있어서이다.
</aside>

### JSXElementName

JSXElementName은 JSXElement의 이름으로 사용가능한 것들을 의미합니다.

- **JSXIndetifier**

  - JSX 내부에서 사용할 수 있는 식별자를 의미한다.
  - 자바스크립트의 식별자 규칙과 동일
  - 숫자로 시작하거나 `$`와 `_`외의 다른 특수 문자로는 시작할 수 없다.
  - 예시

    ```jsx
    function Valid1() {
    	return <$></$>
    }

    function Valid2() {
    	return <_></_>
    }

    // 불가능
    function InValid1() {
    	return <1></1>
    }
    ```

- **JSXNamespacedName(React에선 사용 X)**

  - `JSXIndetifier:JSXIndetifier`의 조합, 즉 `:`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다.
  - `:`로 묶을 수 있는 것은 한 개 뿐이다. 두 개 이상은 올바른 식별자로 취급되지 않는다.
  - 예시

    ```jsx
    function Valid() {
    	return <foo:bar></foo:bar>
    }

    // 불가능
    function InValid() {
    	return <foo:bar:baz></foo:bar:baz>
    }
    ```

- **JSXMemberExpression(React에선 사용 X)**

  - `JSXIndetifier.JSXIndetifier`의 조합, 즉 `.`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다.
  - `:`로 묶는 `JSXNamespacedName`과는 다르게 `.`을 여러 개 이어서 하는 것도 가능하다.
  - 단 `JSXNamespacedName`과 이어서 사용하는 것은 불가능 하다.
  - 예시

    ```jsx
    function Valid1() {
    	return <foo.bar></foo.bar>
    }

    function Valid2() {
    	return <foo.bar.baz></foo.bar.baz>
    }

    // 불가능
    function InValid() {
    	return <foo:bar.baz></foo:bar.baz>
    }
    ```

### JSXAttributes

JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수 값이 아니고, 없다고 에러가 나지 않는다.

- **JSXSpreadAttributes**

  - 자바스크립트의 전개 연산자와 동일한 역할
  - **{…AssignmentExpression}**

    - 이때 `AssignmentExpression`에는 객체뿐만 아니라 조건문 표현식, 화살표 함수, 할당식 등의 모든 표현식이 들어올 수 있습니다.

      ```jsx
      const props = { id: 1, name: "John" };
      const element = <Component {...props} />;

      // 삼항 연산의 결과인 obj를 전개
      const obj = { a: 1 };
      const component = <MyComponent {...(true ? obj : { b: 2 })} />;

      // 함수의 반환 값인 obj를 전개
      const obj = { a: 1 };
      const component = <MyComponent {...(() => obj)()} />;
      ```

- **JSXAttribute**

  - 속성을 나타내는 키와 값으로 짝을 이루어서 표현한다.
  - **JSXAttributeName**
    - 속성의 키 값
    - 키로는 `JSXElementName`에서 언급한 `JSXIdentifier`와 `JSXNamespacedName`이 가능하다.
      ```jsx
      function Valid1() {
        return <foo.bar foo:bar="baz"></foo.bar>;
      }
      ```
  - **JSXAttributeValue**

    - 속성의 키에 할당할 수 있는 값으로, 다음 중 하나에 만족해야 함
    - `“큰따옴표로 구성된 문자열”`: JS문자열과 동일. 내용이 없어도 됨
    - `‘작은따옴표로 구성된 문자열’`: JS문자열과 동일. 내용이 없어도 됨
    - `{ AssignmentExpression }`: `AssignmentExpression`는 JS의 변수에 값으로 넣을 수 있는 모든 표현식을 의미한다.
    - `JSXElement`: 값으로 다른 JSX 요소가 들어갈 수 있다.

      ```jsx
      function Child({ attribute }) {
        return <div>{attribute}</div>;
      }

      export default function App() {
        return (
          <div>
            <Child attribute=<div>hello</div> />
          </div>
        );
      }
      ```

      - 대부분의 React 개발자들은 `<Child attribute={<div>hello</div>} />`와 같이 값으로 들어가는 React component를 `{}`로 감싸는 것이 더 익숙할텐데, 사실 이것은 문법 오류가 아닌 prettier 규칙이다. 이 규칙은 가독성을 더 높이기 위해 제공된다.

    - `JSXFragment`: 값으로 별도 속성을 갖지 않는 형태의 JSX 요소이다. 즉, 비어있는 형태의 `<></>`가 허용된다.

### JSXChildren

JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 한다.

- **JSXChild**
  - JSXChildren을 이루는 기본 단위다.
  - JSXChildren은 JSXChild를 0개 이상 가질 수 있다.
  - 0개를 보면 알 수 있듯 JSXChildren은 JSXChild 가 없어도 된다.
  - `JSXText`
    - `{`, `<`, `>`, `}` 을 제외한 문자열. 이는 다른 JSX문법에 혼동을 줄 수 있기 때문
    - 만약 위 문자를 표현하고 싶다면 따옴표 안에 넣으면 된다.
      ```jsx
      function Vaild() {
        return <>{"{} <>"}</>;
      }
      ```
  - `JSXElement`
    - 값으로 다른 JSX 요소가 들어갈 수 있다.
  - `JSXFragment`
    - 값으로 빈 JSX 요소인 `<></>`가 들어갈 수 있다.
  - `{ JSXChildExpression (optional) }`
    - 이 `JSXChildExpression`는 자바스크립트의 `AssignmentExpression`을 의미한다.
      ```jsx
      // 이 함수를 리액트에서 렌더링하면 "foo"라는 문자열이 출력된다.
      export default function App() {
        return <>{(() => "foo")()}</>;
      }
      ```

### JSXStrings

JSX 문법 내에서 문자열을 처리하는 방법으로 앞서 설명한 `JSXText`와 `JSXAttributeValue`의 따옴표가 이에 포함되며 HTML에서 쓸 수 있는 문자열은 모두 사용가능하다.

주의할 점은 이스케이프 문자 처리에 신경써야 된다.

```jsx
// HTML에서는 \ 문자를 그대로 사용할 수 있다.
<button>\</button>

// JSX에서는 \ 문자를 그대로 사용하면 에러가 발생한다.
return <button>\</button>; // SyntaxError: Unexpected token

// JSX에서 \ 문자를 올바르게 사용하려면 이스케이프 처리를 해야 한다.
return <button>\\</button>; // 올바른 표현

// JavaScript 문자열 내에서 \ 문자를 이스케이프 처리하지 않으면 에러가 발생한다.
let escape1 = "\"; // SyntaxError: Invalid or unexpected token

// \ 문자를 올바르게 이스케이프 처리한 경우
let escape2 = "\\"; // 올바른 표현
```

## JSX는 어떻게 변환되는가

JSX는 `@babel/plugin-transform-react-jsx`를 통해 자바스크립트가 이해할 수 있는 형태로 변환한다.

다음과 같은 JSX 코드가 있다고 가정해보자

```jsx
const ComponentA = <A required={true}>Hello World</A>;

const ComponentB = <>Hello World</>;

const ComponentC = (
  <div>
    <span>hello world</span>
  </div>
);
```

이를 변환한 결과는 다음과 같다.

```jsx
// @babel/plugin-transform-react-jsx로 변환한 결과
"use strict";

var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  "Hello World"
);
var ComponentB = React.createElement(React.Fragment, null, "Hello World");
var ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello world")
);
```

React 17, babel 7.9.0 이후 버전에서 추가된 자동 런타임(automatic runtime)으로 트랜스파일한 결과는 다음과 같다.(두 결과의 자세한 차이점은 8장에서 설명)

```jsx
// 자동 런타임(automatic runtime)으로 변환한 결과
"use strict";

var _jsxRuntime = require("custom-jsx-libray/jsx-runtime");

var ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: "Hello World",
});

var ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: "Hello World",
});

var ComponentC = (0, _jsxRuntime.jsx)("div", {
  children: (0, _jsxRuntime.jsx)("span", {
    children: "hello world",
  }),
});
```

두 결과물에는 약간의 차이가 있지만 다음과 같은 공통점이 있다.

- JSXElement를 첫 번째 인수로 선언해 요소를 정의한다.
- 옵셔널인 `JSXChildren`, `JSXAttributes`, `JSXStrings`는 이후 인수로 넘겨주어 처리한다.

이러한 공통점을 활용한다면 경우에 따라 다른 JSXElement를 렌더링해야할 때 굳이 요소 전체를 감싸지 않아도 처리할 수 있다. 이는 JSXElement만 다르고, `JSXChildren`, `JSXAttributes`이 완전히 동일한 상황에서 중복 코드를 최소화 할 수 있다.

```jsx
// JSX가 변환되는 특성을 이용

// X props 여부에 따라 children 요소만 달라지는 경우
// 굳이 전체 내용을 삼항 연산자로 처리할 필요가 없다.
// 이 경우 불필요한 코드 중복이 일어난다.
function TextOrHeading({ isHeading, children }) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// O JSX가 변환되는 특성을 활용하면 다음과 같이 간결하게 바꿀 수 있다.
import { createElement } from "react";

function TextOrHeading({ isHeading, children }) {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

JSX 반환 값이 결국 `React.createElement`로 귀결된다는 사실을 파악한다면 이런 식으로 쉽게 리팩터링할 수 있다.

# 가상 DOM과 리액트 파이버

## DOM과 브라우저 렌더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드 한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고, 사용자 눈에 보이는 노드만 방문한다. 즉, `display: none`과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정으로 조금이라도 빠르게 하기 위해서다.
6. 5번에서 방문한, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 DOM 노드에 적용하여 렌더트리를 만든다. DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
   - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
   - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

![ch2_DOM_tree_and_CSSOM_tree_to_rendering_tree](image/ch2_DOM_tree_and_CSSOM_tree_to_rendering_tree.png)

## 가상 DOM의 탄생 배경

웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. 웹이 발전하면서 초기 렌더링 이후에도 사용자 인터랙션을 통해 웹페이지가 자주 변경된다. 특히 SPA (Single Page Application) 환경에서는 하나의 페이지 내에서 요소의 위치를 계속 재계산해야 한다. 라우팅이 변경될 때, 사이드바나 헤더 같은 특정 요소를 제외한 대부분의 요소를 삭제하고, 다시 삽입하고, 위치를 재계산해야 한다.

이로 인해 사용자는 페이지 깜박임 없이 자연스러운 탐색을 할 수 있지만, DOM의 관리 부담은 증가한다. 개발자가 모든 인터랙션에 따른 DOM 변화를 추적하는 것은 매우 번거롭다. 대부분의 개발자는 인터랙션 과정에서의 모든 DOM 변경 사항보다는 최종적인 DOM 변화를 알고 싶어한다. 이러한 문제를 해결하기 위해 가상 DOM이 만들어졌다.

### 가상 DOM

웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 React가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저 DOM에 반영한다. 이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한번 거치게 되면 실제로 여러 번 발생했을 렌더링 과정을 최소화 할 수 있다.

## 가상 DOM을 위한 아키텍처, 리액트 파이버

React에서 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 바로 리액트 파이버이다.

### 리액트 파이버

- 리액트에서 관리하는 평범한 자바스크립트 객체
- 파이버 재조정자(fiber reconciler)에 의해 관리됨
  - 파이버 재조정자는 DOM과 DOM 사이의 변경 사항을 수집하고, 두 사이에 차이가 발생하면 변경 정보를 가진 파이버를 기준으로 화면에 렌더링을 요청합니다.
- 리액트 파이버의 기능
  - **작업 분할 및 우선순위 부여**:
    - 작업을 작은 단위로 분할하고, 각 작업에 우선순위를 부여합니다.
  - **작업 일시 중지 및 재개**:
    - 작업을 일시 중지하고 나중에 다시 시작할 수 있습니다.
  - **작업 재사용 및 폐기**:
    - 이전에 했던 작업을 재사용하거나 필요 없을 경우 폐기할 수 있습니다.
- 위에 설명한 기능들이 모두 비동기로 실행
  - 기존 동기적 렌더링 스택의 비효율성을 타파하기 위해 **비동기적으로 작업을 수행하는 파이버라는 개념**이 탄생했습니다.
  - 리액트 파이버의 작업은 모두 비동기로 처리되어, 사용자 인터페이스를 더 부드럽고 빠르게 만듭니다.
- 파이버의 작업 단계
  - **렌더 단계**
    - 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 이 단계에서 수행합니다.
    - 이 단계에서 파이버의 작업, 우선순위 지정, 작업 일시 중지 및 폐기 등이 발생합니다.
  - **커밋 단계**
    - DOM에 실제 변경 사항을 반영하는 단계로, `commitWork()`가 실행됩니다.
    - 이 과정은 동기적으로 일어나며 중단될 수 없습니다.

### 리액트 내부 코드로 보는 파이버

- 리액트 내부 코드의 파이버 객체

```jsx
function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.refCleanup = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = NoLanes;

  // 이하 프로파일러, __DEV__ 코드는 생략
}
```

보다시피 파이버는 단순한 자바스크립트 객체로 구성되어 있다.

보통 React 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다. 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용한다.

- 리액트에 작성돼 있는 파이버를 생성하는 다양한 함수

```jsx
var createFiber = function (tag, pendingProps, key, mode) {
	return new FiberNode(tag, pendingProps, key, mode)
}

// 생략...
function createFiberFromElement(element, mode, lanes) {
	var owner = null

	{
		owner = element._owner
	}

	var type = element.type
	var key = element.key
	var pendingProps = element.props
	var fiber = createFiberFromTypeAndProps(
		type,
		key,
		pendingProps,
		owner,
		mode
		lanes,
	)

	{
		fiber._debugSource = element._source
		fiber._debugOwner = element._owner
	}

	return fiber
}

function createFiberFromFragment(element, mode, lanes, key) {
	var fiber = createFiber(Fragment, elements, key, mode)
	fiber.lanes = lanes
	return fiber
}
```

함수명을 보면 알 수 있듯이 리액트 파이버는 하나의 element와 1:1로 대응된다.

이제 리액트 파이버의 주요 속성을 알아보자

- **tag**
  - 파이버와 element의 1:1로 매칭된 정보를 가지고 있다. 1:1로 연결 되는 것은 React Component일 수도, HTML의 DOM 노드일 수도, 혹은 다른 어떤 것일 수도 있다.
  - React에 작성되어 있는 파이버의 태그가 가질 수 있는 값들
    ```jsx
    var FunctionComponent = 0; // 함수형 컴포넌트
    var ClassComponent = 1; // 클래스형 컴포넌트
    var IndeterminateComponent = 2; // 함수형인지 클래스형인지 알기 전 상태
    var HostRoot = 3; // 호스트 트리의 루트
    var HostPortal = 4; // 서브트리, 다른 렌더러의 진입점이 될 수 있음
    var HostComponent = 5; // 일반 HTML 요소
    var HostText = 6; // 텍스트 노드
    var Fragment = 7; // 프래그먼트
    var Mode = 8; // 모드
    var ContextConsumer = 9; // 컨텍스트 소비자
    var ContextProvider = 10; // 컨텍스트 제공자
    var ForwardRef = 11; // 참조 전달
    var Profiler = 12; // 성능 프로파일러
    var SuspenseComponent = 13; // 서스펜스 컴포넌트
    var MemoComponent = 14; // 메모 컴포넌트
    var SimpleMemoComponent = 15; // 간단한 메모 컴포넌트
    var LazyComponent = 16; // 레이지 로딩 컴포넌트
    var IncompleteClassComponent = 17; // 불완전한 클래스형 컴포넌트
    var DehydratedFragment = 18; // 비활성화된 프래그먼트
    var SuspenseListComponent = 19; // 서스펜스 리스트 컴포넌트
    var ScopeComponent = 21; // 스코프 컴포넌트
    var OffscreenComponent = 22; // 오프스크린 컴포넌트
    var LegacyHiddenComponent = 23; // 레거시 히든 컴포넌트
    var CacheComponent = 24; // 캐시 컴포넌트
    var TracingMarkerComponent = 25; // 트레이싱 마커 컴포넌트
    ```
- **stateNode**
  - 파이버 자체에 대한 참조(reference) 정보를 가지고 있다.
  - 이 참조를 바탕으로 React는 파이버와 관련된 상태에 접근한다.
- **child, sibling, return**

  - 파이버 간의 관계를 나타내는 속성이다.
  - 리액트 컴포넌트가 트리를 가지는 것 처럼 파이버도 트리를 가짐
    - 이 트리의 관계를 정의하는데 필요한 요소가 **child, sibling, return**
  - 리액트 트리와 다른 점은 하나의 child만 가질 수 있다.
  - 위에서 파이버 트리는 하나의 child만 가질 수 있다고 하였는데, 그렇다면 아래와 같은 여러 자식을 가지는 구조는 어떻게 표현 할까?

    ```jsx
    <ul>
      <li>하나</li>
      <li>둘</li>
      <li>셋</li>
    </ul>
    ```

    파이버는 항상 첫 번째 자식의 참조로 구성이 되며 나머지 형제는 sibling으로 구성하게 된다.

    ```jsx
    const l3 = {
      return: ul,
      index: 2,
    };

    const l2 = {
      sibling: l3,
      return: ul,
      index: 1,
    };

    const l1 = {
      sibling: l2,
      return: ul,
      index: 1,
    };

    const ul = {
      // ...
      child: l1,
    };
    ```

- **index**
  - 여러 형제들(sibling) 사이에서 자신의 위치가 몇 번째인지 숫자로 표현
- **pendingProps**
  - 아직 작업을 미처 처리하지 못한 props
- **mempizedProps**
  - pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 mempizedProps로 저장하여 관리
- **updateQueue**
  - 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐
  - 구조
    ```tsx
    type UpdateQueue = {
      first: Update | null;
      last: Update | null;
      hasForceUpdate: boolean;
      callbackList: null | Array<Callback>; // setState로 넘긴 콜백 목록
    };
    ```
- **memorizedState**
  - 함수 컴포넌트의 훅 목록이 저장
  - useState뿐만 아니라 모든 훅 리스트가 저장됨
- **alternate**
  - 뒤이어 설명할 리액트 파이버 트리와 연관된 내용
  - 리액트 파이버 트리는 두개인데, 그 반대편 파이버 트리는 가리킨다.

이렇게 생성된 파이버는 상태가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. 리액트는 파이버를 처리할 때마다 파이버의 우선순위를 매겨 중요한 작업은 빨리 실행하고 덜 중요한 작업은 늦게 실행하는 등의 스케줄링을 한다.

### 리액트 파이버 트리

- 리액트 파이버들의 부모-자식 관계를 나타내는 트리
- 리액트 내부에 두 개가 존재
  - 현재의 모습을 담은 파이버 트리
  - 작업 중인 상태를 나타내는 workInProcess 트리
- 리액트 파이버의 작업이 끝나면 workInProcess 트리를 현재 트리로 변경한다.
  - 더블 버퍼링이라고 부른다.
- 하나의 트리 만을 사용하는 경우 불완전한 화면을 노출 할 수 있기 때문이다.

리액트 파이버 트리의 동작 순서

![react_fiber_tree](image/ch2_react_fiber_tree.png)

1. current 트리를 기준으로 현재 UI 렌더링
2. 업데이트 발생 시 current를 기준으로 새로운 workInProcess 빌드
3. workInProcess 트리를 기준으로 변경된 UI 렌더링
4. workInProcess 트리가 current 트리로 변경

### 파이버의 작업 순서

파이버 트리와 파이버가 어떤 식으로 작동하는지 흐름을 살펴보자. 먼저 일반적인 파이버 노드의 생성 흐름은 다음과 같다.

1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 깊게 들어간다.
2. 1번에서 작업이 끝난다면 그다음 `completeWork()` 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

다음 예제 코드를 통해 확인해 보자.

```jsx
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1 />
      <D2 />
    </C1>
  </B2>
  <B3 />
</A1>
```

위 작업은 JSX코드에서 다음과 같은 순서로 실행된다.

1. `A1`의 `beginWork()` 가 수행된다.
2. `A1`은 자식이 있으므로 B1으로 이동해 `beginWork()`를 수행한다.
3. `B1`은 자식이 없으므로 `completeWork()`가 수행됐다. 자식이 없으므로 형제인 `B2`로 넘어간다.
4. `B2`의 `beginWork()`가 수행된다. 자식이 있으므로 `C1`으로 이동한다.
5. `C1`의 `beginWork()`가 수행된다. 자식이 있으므로 `D1`으로 이동한다.
6. `D1`의 `beginWork()`가 수행된다.
7. `D1`은 자식이 없으므로 `completWork()`가 수행됐다. 자식은 없으므로 형제인 `D2`로 넘어간다.
8. `D2`는 자식이 없으므로 `completWork()`가 수행됐다.
9. `D2`는 자식도 더 이상의 형제도 없으므로 위로 이동해 `D1`, `C1`, `B1` 순으로 `completeWork()`를 호출한다.
10. `B2`는 형제인 `B3`로 이동해 `beginWork()`를 수행한다.
11. `B3`의 `completeWork()`가 수행되면 반환해 상위로 타고 올라간다.
12. `A1`의 `completeWork()`가 수행된다.
13. 루트 노드가 완성되는 순간, 최종적으로 `commitWork()`가 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영된다.

이렇게 생성한 트리를 도식화하면 다음과 같다.

![react_code_to_react_fiber_tree](image/ch2_react_code_to_react_fiber_tree.png)

이렇게 트리가 생성됐다. 이제 여기서 setState 등으로 업데이트가 발생하면 어떻게 될까?

1. 업데이트 요청을 받아 workInProgregg 트리를 다시 빌드하기 시작
   - 이미 리액트는 앞서 만든 current 트리가 존재
   - 이 빌드 과정은 앞서 트리를 만드는 과정과 동일
2. 파이버 재사용
   - 파이버가 이미 존재하므로 되도록 새로 생성 X
   - 최초 렌더링 시에는 모든 파이버를 새롭게 생성해야 했음
3. 업데이트된 props 처리
   - 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리

이제 앞에서 언급한 것들을 다시 살펴보자

**가급적 새로운 파이버를 생성하지 않는다.**

- 트리를 비교하고 업데이트하는 과정은 빈번하게 발생한다.
- 이러한 반복적인 재조정 작업마다 새로운 파이버 객체를 생성하는 것은 리소스 낭비다.
- 따라서, 새로운 객체를 만들기보다는 기존에 있는 객체를 재활용하기 위해 내부 속성 값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.

**과거에는 동기식으로 처리했지만 비동기로 변경**

- 과거에는 이 트리 업데이트 과정이 동기식으로 처리되어 중단될 수 없었다.
- 현재는 우선순위에 따라 비동기적으로 작업을 수행한다.
  - 우선순위에 따라 현재 작업을 중단하거나, 새롭게 실행하거나, 폐기할 수 있다.
- 리액트는 작업을 파이버 단위로 나눠서 수행한다.
  - 애니메이션이나 사용자가 입력하는 작업을 높은 우선순위로 분류한다.
  - 목록을 렌더링하는 등의 작업을 낮은 우선순위로 분류한다.
  - 이로써 최적의 순위로 작업을 완료할 수 있게 한다.

## 파이버와 가상 DOM

- **가상 DOM**:
  - 가상 DOM은 웹 애플리케이션에서만 사용된다.
  - 리액트 네이티브와 같은 브라우저가 아닌 환경에서는 사용되지 않는다.
- **리액트 파이버**:
  - 리액트 파이버는 브라우저가 아닌 환경에서도 사용 가능하다.
  - 리액트와 리액트 네이티브의 렌더러가 서로 다르더라도, 내부적으로 파이버를 통해서 조정되는 과정은 동일하다.
  - 이를 통해 재
