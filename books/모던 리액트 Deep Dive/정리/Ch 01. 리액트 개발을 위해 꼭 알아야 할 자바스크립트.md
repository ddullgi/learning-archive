# 목차

- 1.1 [자바스크립트 데이터 타입과 동등 비교](#자바스크립트-데이터-타입과-동등-비교)
- 1.2 [함수](#함수)

# 자바스크립트 데이터 타입과 동등 비교

## 자바스크립트의 데이터 타입

### 원시타입(primitive type)

- 객체가 아닌 다른 모든 타입

#### undefined

- 선언한 후 값을 할당하지 않은 변수
- 값이 주어지지 않은 인수에 자동으로 할당되는 값

#### null

- 명시적으로 비어 있음을 나타내는 값
- **typeof로 확인하면 “object”가 반환 됨**
  - 초창기 자바스크립트 방식에 따른 문제
  - 안고쳐졌음

#### Boolean

- 참(true)와 거짓(false)만을 가질 수 있는 데이터 타입

> 조건문에서는 boolean 값 외에도 참, 거짓과 같이 취급되는 `truthy`, `falsy` 값이 존재한다.

`falsy`: 조건문 내부에서 false로 취급되는 값

> | 값                      | 타입            | 설명                                                                   |
> | ----------------------- | --------------- | ---------------------------------------------------------------------- |
> | false                   | Boolean         | **false**는 대표적인 `falsy`한 값이다.                                 |
> | `0`, `-0`, `0n`, `0x0n` | Boolean, BigInt | **0**은 부호나 소수점 유무에 상관없이 `falsy`한 값이다.                |
> | NaN                     | Number          | Number가 아니라는 것을 뜻하는 NaN은 `falsy`한 값이다.                  |
> | `‘’` , `""` , ````      | String          | 문자열이 `falsy`하기 위해서는 반드시 공백이 없는 빈 문자열이어야 한다. |
> | null                    | null            | **null**은 `falsy`한 값이다.                                           |
> | undefined               | undefined       | **undefined**는 `falsy`한 값이다.                                      |
>
> `truthy`: 조건문 내부에서 true로 취급되는 값, 앞에 언급한 `falsy`로 취급되는 값 이외에는 모두 true로 취급한다. 한 가지 유념할 점은 객체와 배열은 내부에 값이 존재하는지 여부와 상관 없이 `truthy`로 취급한다. 즉, `{}` , `[]` 모두 `truthy`한 값이다

### Number

- 모든 숫자를 표현한다.(BigInt 등장 이전까지)
- `-(2^53 - 1)` 과 `2^53 - 1` 사이의 값을 저장한다.
- 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않음
  - 각 진수별로 값을 저장해도 10진수로 표현된다.

### BigInt

- **Number**의 크기 제한을 극복하기 위해 ES2020에 등장했다.
- **Number**보다 큰 값을 저장할 수 있다.

```jsx
// 기존 number의 한계
9007199254740992 === 9007199254740993; // 마지막 숫자가 다르지만 true가 나온다.
// 이보다 큰 값을 다룰 수 없기 때문

// BigInt 사용법
const bigInt1 = 9007199254740995n; // 끝에 n을 붙이거나
const bigInt2 = BigInt("9007199254740995"); // BigInt 함수를 사용하면 된다.
```

#### String

- 텍스트 타입의 데이터를 저장한다.
- `‘’` , `""` , ```` 을 통해 표현
- 백틱을 사용한 경우
  - 내장 표현식을 사용할 수 있고, 이를 템플릿 리터럴이라 부른다.
  - 줄바꿈이 가능하다.
- 문자열을 원시 타입이다.
  - 한번 생성되면 그 일부를 수정할 수 없다.

#### Symbol

- 중복되지 않는 어떤 고유한 값을 나타내기 위해 사용한다.
- ES6에 새롭게 추가된 7번째 타입이다.
- Symbol 함수를 이용해서만 만들 수 있다.

```jsx
// Symbol함수에 같은 인수를 넘겨주더라도 이는 동일한 값으로 인정되지 않는다.
// 심벌 함수 내부에 넘겨주는 값은 Symbol 생성에 영향을 미치지 않는다(Symbol.for 제외)
const key = Symbol("key");
const key2 = Symbol("key");

key === key2; // false

// 동일한 값을 사용하기 위해서는 Symbol.for를 활용한다.
Symbol.for("hello") === Symbol.for("hello"); //true
```

### 객체 타입(object/reference type)

- 앞서 설명한 7가지 원시 타입 이외의 모든 것
- 여기에는 배열, 함수, 정규식, 클래스 등이 포함된다.
- 객체 타입은 참조를 전달한다고 해서 참조타입으로도 불린다.

```jsx
typeof [] === "object"; // true
typeof {} === "object"; // true

function hello() {}
typeof hello === "fuction"; // true

const hello1 = function () {};
const hello2 = function () {};

// 객체인 함수의 내용이 육안으로는 같아보여도 참조가 다르기 때문에 false가 반환된다.
hellp1 === hello2; // false
```

## 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식의 차이이다.

#### 원시 타입

- 불변의 형태의 값이 저장된다.
- 할당 시점에 메모리 영역을 차지한다.

#### 객체 타입

- 변경 가능한 형태로 저장된다.
- 값이 아닌 참조를 저장한다.
- 복사할 때도 값이 아닌 참조를 전달한다.
- 동일하게 두 번 선언해도 다른 참조를 저장해서 다른 값이 된다.

## Object.is

- ES6에서 새롭게 도입된 비교 문법

```jsx
Object.is(a, b);
```

- `===` 의 한계를 극복하기 위해 도입 됨
- 그러나 여전히 객체 비교에 있어서는 `===` 과 동일하게 동작

|                   | ==                       | ===         | Object.is   |
| ----------------- | ------------------------ | ----------- | ----------- |
| 다른 타입 비교 시 | 강제로 형 변환 하여 비교 | 그대로 비교 | 그대로 비교 |

| 계산 결과가 같은 수식 비교 시
ex) `-0 과 +0` , `NaN 과 0 / 0` | 계산 결과로 비교 | 계산 결과로 비교 | 수식 그대로 비교
수식 모양이 다르면 `false` |

#### 객체 비교 시

`Object.is` 를 사용하더라도 참조 값을 비교한다.

```jsx
Object.is({}, {}); // false

const a = {
  hello: "hi",
};

const b = a;

Object.is(a, b); // true
a === b; // true
```

### 리액트에서의 동등 비교

리액트에서는 `Object.is`를 기반으로 동등 비교를 하는 `shallowEqual`라는 함수를 사용한다.

#### shallowEqual

- 함수 내부에서 기본적으로 `Object.is`를 사용해서 비교
- `Object.is` 가 수행하지 못하는 객체 간 얕은 비교를 추가적으로 수행
- 2 depth 부터는 비교 불가

```jsx
// Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
Object.is({ hello: "world" }, { hello: "world" }); // false

// 반면 리액트 팀에서 구현한 shallowEqual은 객체의 1 depth까지는 비교가 가능하다.
shallowEqual({ hello: "world" }, { hello: "world" }); // true

// 그러나 2 depth 까지 가면 이를 비교할 방법이 없으므로 false를 반환한다.
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
```

#### 의존성 배열의 비교

리액트는 `useMemo`, `useCallback`, `useEffect`에서 의존성 배열은 `shallowEqual` 함수를 사용해 변경 여부를 비교한다. 즉, 2 depth 이상의 의존성 배열의 변경을 비교할 수

# 함수
