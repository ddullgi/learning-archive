# 목차

- 1.1 [자바스크립트 데이터 타입과 동등 비교](#자바스크립트-데이터-타입과-동등-비교)
- 1.2 [함수](#함수)
- 1.3 [클래스](#클래스)

# 자바스크립트 데이터 타입과 동등 비교

## 자바스크립트의 데이터 타입

### 원시타입(primitive type)

- 객체가 아닌 다른 모든 타입

#### undefined

- 선언한 후 값을 할당하지 않은 변수
- 값이 주어지지 않은 인수에 자동으로 할당되는 값

#### null

- 명시적으로 비어 있음을 나타내는 값
- **typeof로 확인하면 “object”가 반환 됨**
  - 초창기 자바스크립트 방식에 따른 문제
  - 안고쳐졌음

#### Boolean

- 참(true)와 거짓(false)만을 가질 수 있는 데이터 타입

> 조건문에서는 boolean 값 외에도 참, 거짓과 같이 취급되는 `truthy`, `falsy` 값이 존재한다.

`falsy`: 조건문 내부에서 false로 취급되는 값

> | 값                      | 타입            | 설명                                                                   |
> | ----------------------- | --------------- | ---------------------------------------------------------------------- |
> | false                   | Boolean         | **false**는 대표적인 `falsy`한 값이다.                                 |
> | `0`, `-0`, `0n`, `0x0n` | Boolean, BigInt | **0**은 부호나 소수점 유무에 상관없이 `falsy`한 값이다.                |
> | NaN                     | Number          | Number가 아니라는 것을 뜻하는 NaN은 `falsy`한 값이다.                  |
> | `‘’` , `""` , ````      | String          | 문자열이 `falsy`하기 위해서는 반드시 공백이 없는 빈 문자열이어야 한다. |
> | null                    | null            | **null**은 `falsy`한 값이다.                                           |
> | undefined               | undefined       | **undefined**는 `falsy`한 값이다.                                      |
>
> `truthy`: 조건문 내부에서 true로 취급되는 값, 앞에 언급한 `falsy`로 취급되는 값 이외에는 모두 true로 취급한다. 한 가지 유념할 점은 객체와 배열은 내부에 값이 존재하는지 여부와 상관 없이 `truthy`로 취급한다. 즉, `{}` , `[]` 모두 `truthy`한 값이다

### Number

- 모든 숫자를 표현한다.(BigInt 등장 이전까지)
- `-(2^53 - 1)` 과 `2^53 - 1` 사이의 값을 저장한다.
- 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않음
  - 각 진수별로 값을 저장해도 10진수로 표현된다.

### BigInt

- **Number**의 크기 제한을 극복하기 위해 ES2020에 등장했다.
- **Number**보다 큰 값을 저장할 수 있다.

```jsx
// 기존 number의 한계
9007199254740992 === 9007199254740993; // 마지막 숫자가 다르지만 true가 나온다.
// 이보다 큰 값을 다룰 수 없기 때문

// BigInt 사용법
const bigInt1 = 9007199254740995n; // 끝에 n을 붙이거나
const bigInt2 = BigInt("9007199254740995"); // BigInt 함수를 사용하면 된다.
```

#### String

- 텍스트 타입의 데이터를 저장한다.
- `‘’` , `""` , ```` 을 통해 표현
- 백틱을 사용한 경우
  - 내장 표현식을 사용할 수 있고, 이를 템플릿 리터럴이라 부른다.
  - 줄바꿈이 가능하다.
- 문자열을 원시 타입이다.
  - 한번 생성되면 그 일부를 수정할 수 없다.

#### Symbol

- 중복되지 않는 어떤 고유한 값을 나타내기 위해 사용한다.
- ES6에 새롭게 추가된 7번째 타입이다.
- Symbol 함수를 이용해서만 만들 수 있다.

```jsx
// Symbol함수에 같은 인수를 넘겨주더라도 이는 동일한 값으로 인정되지 않는다.
// 심벌 함수 내부에 넘겨주는 값은 Symbol 생성에 영향을 미치지 않는다(Symbol.for 제외)
const key = Symbol("key");
const key2 = Symbol("key");

key === key2; // false

// 동일한 값을 사용하기 위해서는 Symbol.for를 활용한다.
Symbol.for("hello") === Symbol.for("hello"); //true
```

### 객체 타입(object/reference type)

- 앞서 설명한 7가지 원시 타입 이외의 모든 것
- 여기에는 배열, 함수, 정규식, 클래스 등이 포함된다.
- 객체 타입은 참조를 전달한다고 해서 참조타입으로도 불린다.

```jsx
typeof [] === "object"; // true
typeof {} === "object"; // true

function hello() {}
typeof hello === "fuction"; // true

const hello1 = function () {};
const hello2 = function () {};

// 객체인 함수의 내용이 육안으로는 같아보여도 참조가 다르기 때문에 false가 반환된다.
hellp1 === hello2; // false
```

## 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식의 차이이다.

#### 원시 타입

- 불변의 형태의 값이 저장된다.
- 할당 시점에 메모리 영역을 차지한다.

#### 객체 타입

- 변경 가능한 형태로 저장된다.
- 값이 아닌 참조를 저장한다.
- 복사할 때도 값이 아닌 참조를 전달한다.
- 동일하게 두 번 선언해도 다른 참조를 저장해서 다른 값이 된다.

## Object.is

- ES6에서 새롭게 도입된 비교 문법

```jsx
Object.is(a, b);
```

- `===` 의 한계를 극복하기 위해 도입 됨
- 그러나 여전히 객체 비교에 있어서는 `===` 과 동일하게 동작

|                   | ==                       | ===         | Object.is   |
| ----------------- | ------------------------ | ----------- | ----------- |
| 다른 타입 비교 시 | 강제로 형 변환 하여 비교 | 그대로 비교 | 그대로 비교 |

| 계산 결과가 같은 수식 비교 시
ex) `-0 과 +0` , `NaN 과 0 / 0` | 계산 결과로 비교 | 계산 결과로 비교 | 수식 그대로 비교
수식 모양이 다르면 `false` |

#### 객체 비교 시

`Object.is` 를 사용하더라도 참조 값을 비교한다.

```jsx
Object.is({}, {}); // false

const a = {
  hello: "hi",
};

const b = a;

Object.is(a, b); // true
a === b; // true
```

### 리액트에서의 동등 비교

리액트에서는 `Object.is`를 기반으로 동등 비교를 하는 `shallowEqual`라는 함수를 사용한다.

#### shallowEqual

- 함수 내부에서 기본적으로 `Object.is`를 사용해서 비교
- `Object.is` 가 수행하지 못하는 객체 간 얕은 비교를 추가적으로 수행
- 2 depth 부터는 비교 불가

```jsx
// Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
Object.is({ hello: "world" }, { hello: "world" }); // false

// 반면 리액트 팀에서 구현한 shallowEqual은 객체의 1 depth까지는 비교가 가능하다.
shallowEqual({ hello: "world" }, { hello: "world" }); // true

// 그러나 2 depth 까지 가면 이를 비교할 방법이 없으므로 false를 반환한다.
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
```

#### 의존성 배열의 비교

리액트는 `useMemo`, `useCallback`, `useEffect`에서 의존성 배열은 `shallowEqual` 함수를 사용해 변경 여부를 비교한다. 즉, 2 depth 이상의 의존성 배열의 변경을 비교할 수

# 함수

## 함수란?

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감써서 실행 단위로 만들어 놓은 것을 의미한다.

## 함수를 정의하는 4가지 방법

### 함수 선언문

자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식이다.

```jsx
function add(a, b) {
  return a + b;
}
```

함수 선언문은 말 그대로 `선언`이고 어떠한 값도 표현하지 않으므로 표현식이 아닌 일반 문으로 분류된다.

### 함수 표현식

앞서 설명한 함수 선언식을 변수에 할당해서 사용하는 방식이다.

```jsx
const sum = function (a, b) {
  return a + b;
};

sum(10, 24); // 34
```

자바스크립트의 함수는 일급 객체이기 때문에 변수에 할당이 가능하다.

### 함수 선언문과 함수 표현식의 차이

호이스팅 과정에서 차이가 발생한다. 선언문 같은 경우 함수 선언 이전에 함수를 호출해도 정상적으로 함수가 실행되는 반면 표현식의 경우는 호이스팅 시점에는 undefined로 초기화된다.

### Function 생성자

```jsx
const add = new Function("a", "b", "return a + b");

add(10, 24); // 34
```

Function 생성자를 통해 함수를 생성하는 방식이다. 코드 작성에 있어서도 불편하고 권장하지 않는 방이다.

### 화살표 함수

ES6에 새로 추가된 함수 생성 방식으로 function이라는 키워드 대신 ⇒ 라는 화살표를 사용하여 함수를 만든다.

```jsx
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

### 화살표 함수의 특징

- constructor를 사용할 수 없다.

  - 즉, 화살표 함수는 생성자 함수로 사용할 수 없다.

  ```jsx
  const Car = (name) => {
    this.name = name;
  };

  // Uncaught TypeError: Car is not a constructor
  const myCar = new Car("하이");
  ```

- arguments가 존재하지 않는다.

  ```jsx
  function hello() {
    console.log(arguments);
  }

  // Arguments(3) [1, 2, 3, calle: f, Symbol(Symbol.iterator): f]
  hello(1, 2, 3);

  const hi = () => {
    console.log(arguments);
  };

  // Uncaught ReferenceError: arguments is not defined
  hi(1, 2, 3);
  ```

- 함수 자체의 this 바인딩을 가지지 않는다.
  - 상위 스코프의 this를 그대로 따른다.

## 다양한 함수 살펴보기

### 즉시 실행 함수

정의하는 순간 즉시 실행되는 함수를 의미하며 `IIFE`라고 부른다.

```jsx
(function (a, b) {
		return a + b
})(10, 24); // 34

((a, b) => {
		return a + b
	},
)(10, 24); // 34
```

- 즉시 실행 함수는 한 번 선언 하고 호출된 이후부터는 더 이상 재호출이 불가능하다.
  - 때문에 즉시 실행 함수에는 보통 이름을 붙이지 않는다.
- 다시금 호출되지 않기 때문에 글로벌 스코프를 오염시키지 않고 독립적인 함수 스코프로 작동한다.

### 고차 함수

자바스크립트가 함수가 일급 객체라는 특징을 활용하여 함수를 인수로 받거나 결과로 새로운 함수를 반환하는 함수이다.

```jsx
// 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
const doubleArray = [1, 2, 3].map((item) => item * 2);

doubleArray; // [2, 4, 6]

// 함수를 반환하는 고차 함수의 예
const add = function (a) {
  // a가 존재하는 클로저를 생성
  return function (b) {
    // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    return a + b;
  };
};

add(1)(3); // 4
```

## 함수를 만들 때 주의해야 할 사항

### 함수의 부수 효과 최대한 억제하기

- 부수 효과(side-effect)란 함수 내의 작동으로 인해 함수 외부에 영향을 끼치는 것
- 부수 효과가 없는 순수 함수는 언제 어디서나 동일한 인수에 대해 동일한 결과를 반환 한다.
  - 그리고 이 과정에서 외부에 어떠한 영향도 미쳐서는 안된다.

### 가능한 함수를 작게 만들기

코드가 길어질 수록 코드 냄새가 날 확률이 커지고 내부의 상황을 추적하기 힘들어지기 때문에 코드의 크기를 줄이는 것이 좋다.

### 누구나 이해할 수 있는 이름을 붙이기

프로젝트의 규모가 커지고 함께하는 동료가 많아질 수록 코드를 이해하기 힘들어지기 때문에 한눈에 누구나 이해할 수 있는 함수명을 작성하는게 좋다

# 클래스

자바스크립트의 클래스는 특정 객체를 만들기 위한 일종의 템플릿으로 볼 수 있다. 즉, 클래스는 특정 형태의 객체를 반복적으로 생성하는 데 사용된다.

### 클래스 예제

```jsx
// Car 클래스 선언
class Car {
  // constructor는 생성자다. 객체 생성 시 인수를 받고 초기화하는 데 사용된다.
  constructor(name) {
    this.name = name;
  }

  // 메서드
  hook() {
    console.log(`${this.name}이 경적을 울립니다!`);
  }

  // 정적 메서드
  static hello() {
    console.log("저는 자동차입니다");
  }

  // setter
  set age(value) {
    this.carAge = value;
  }

  // getter
  get age() {
    return this.carAge;
  }
}

// Car 클래스로 car 객체 생성
const myCar = new Car("자동차");

// 메서드 호출
myCar.hook();

// 정적 메서드는 클래스에서 직접 호출
Car.hello();

// 정적 메서드는 클래스로 만든 객체에서 호출 불가
// Uncaught TypeError: myCar.hello is not a function
myCar.hello();

// setter로 값 할당
myCar.age = 32;

// getter로 값 가져오기
console.log(myCar.age, myCar.name); // 32 자동차
```

이제 클래스 내부의 각 특징을 살펴보자.

## constructor

- 객체를 초기화하는 데 사용되는 특수한 메서드다.
- 클래스당 하나만 존재할 수 있다.
  - 여러 개 사용 시 에러 발생
- 생성자에서 수행할 작업이 없다면 생략 가능하다.

## 프로퍼티

- 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값이다.

```jsx
class Car {
  constructor(name) {
    // 받은 값을 내부 프로퍼티로 할당
    this.name = name;
  }
}

const myCar = new Car("자동차"); // 프로퍼티 값 전달
```

- 인스턴스 생성 시 constructor 내부에 빈 객체가 할당된다.
  - 이 빈 객체에 프로퍼티의 키와 값이 저장된다.

## getter와 setter

getter는 클래스에서 값을 가져올 때 사용된다. getter를 사용하려면 'get' 키워드를 앞에 붙이고, 이어서 getter의 이름을 선언해야 한다.

```jsx
constructor(name) {
		this.name = name
	}

	get firstCharacter() {
		return this.name[0]
	}
}

const myCar = new Car("자동차")

myCar.firstCharacter // '자'
```

반면 setter는 클래스 필드에 값을 할당할 때 사용한다. 마찬가지로 'set' 키워드를 먼저 선언하고, 그 뒤에 이름을 붙인다.

```jsx
	constructor(name) {
		this.name = name
	}

	get firstCharacter() {
		return this.name[0]
	}

	set firstCharacter(char) {
		tgus.name = [char, ...this.name.slice(1)].join("")
	}
}

const mayCar = new Car("자동차")

myCar.firstCharacter // 자

// "차"를 할당한다.
myCar.firstCharacter = "차"

console.log(myCar.firstCharacter, myCar.name) // 차, 차동차
```

## 인스턴스 메서드

클래스 내부에서 선언한 메서드를 인스턴스 메서드라고 한다. 이는 실제로 자바스크립트의 프로토타입에 선언되므로 프로토타입 메서드로도 불린다.

프로토타입에 선언된다는 의미를 자세히 살펴보자.

```jsx
class Car {
  constructor(name) {
    this.name = name;
  }

  hook() {
    console.log(`${this.name}이 경적을 울립니다!`);
  }
}

const myCar = new Car("자동차");

Object.getPrototypeOf(myCar); // {constructor: f, hook: f}
Object.getPrototypeOf(myCar) === Car.prototype; // true
```

위 코드에서 클래스에서 선언한 hook 인스턴스 메서드를 `Object.getPrototypeOf()`와 `객체.prototype`을 통해 가져오는 것을 볼 수 있다. 이는 자바스크립트의 클래스가 프로토타입을 이용해 만든 문법적 설탕(syntactic sugar)이기 때문이다.

또한 클래스에서 직접 선언하지 않았음에도 프로토타입에 있는 부모의 메서드를 찾아 실행할 수 있는 이유는 프로토타입 체이닝 때문이다. 자바스크립트의 모든 객체는 프로토타입을 가지고 있으며, 특정 속성을 찾을 때 자기 자신부터 시작해 프로토타입을 타고 최상위 객체인 Object까지 탐색한다. 위의 코드에서 myCar는 부모인 Car에서 hook 메서드를 찾는 프로토타입 체이닝을 거쳐 hook을 호출할 수 있게 된다.

결론적으로 프로토타입과 프로토타입 체이닝이라는 특성 덕분에 자식 클래스에서 직접 선언하지 않은 인스턴스 메서드를 호출할 수 있게 된다.

## 정적 메서드

- 클래스 내부에서 `static` 키워드를 사용해 선언한 메서드
- 인스턴스가 아닌 클래스 자체에 속하며 인스턴스에서는 호출할 수 없다.
  - 인스턴스를 생성하지 않고 사용할 수 있다.
  - 전역에서 사용하는 유틸 함수를 만들 때 많이 활용된다.

```jsx
class Car {
  static hello() {
    console.log("안녕하세요!");
  }
}

const myCar = new Car();

Car.hello(); // 안녕하세요!
myCar.hello(); // Uncaught TypeError: myCar.hello is not a function
```

## 상속

- `extends`를 사용하여 자식 클래스가 부모 클래스의 특성을 확장하는 개념이다.
- 확장 시 부모 클래스의 메서드를 자식 클래스에서 재정의하면, 새로운 메서드가 기존 메서드를 대체한다.
  - 이를 "메서드 오버라이딩"이라고 한다.

```jsx
class Car {
  constructor(name) {
    this.name = name;
  }

  hook() {
    console.log(`${this.name} 경적을 울립니다!`);
  }
}

class Truck extends Car {
  constructor(name) {
    // 부모 클래스의 constructor, 즉 Car의 constructor를 호출한다.
    super(name);
  }

  load() {
    console.log("짐을 싣습니다.");
  }
}

const myCar = new Car("자동차");
myCar.hook(); // 자동차 경적을 울립니다.

const truck = new Truck("트럭");
truck.hook(); // 트럭 경적을 울립니다.
truck.load(); // 짐을 싣습니다.
```

## 클래스와 함수의 관계

클래스는 ES6에 나온 방식으로, ES6 이전에는 프로토타입을 활용해 클래스의 작동 방식과 동일하게 구현 할 수 있었다. 즉, 자바스크립트에서는 클래스가 하는 일을 함수가 동일하게 수행할 수 있다.

```jsx
// 클래스 코드
class Car {
  constructor(name) {
    this.name = name;
  }

  hook() {
    console.log(`${this.name}이 경적을 울립니다!`);
  }

  static hello() {
    console.log("저는 자동차입니다");
  }

  set age(value) {
    this.carAge = value;
  }

  get age() {
    return this.carAge;
  }
}

// 함수 코드
var Car = (function () {
  function Car(name) {
    this.name = name;
  }

  // 프로토타입 메서드. 실제로 프로토타입에 할당해야 프로토타입 메서드로 작동한다.
  Car.prototype.hook = function () {
    console.log(`${this.name}이 경적을 울립니다!`);
  };

  // 정적 메서드. 인스턴스 생성 없이 바로 호출 가능하므로 직접 할당했다.
  Car.hello = function () {
    console.log("저는 자동차입니다");
  };

  // Car 객체에 속성을 직접 정의했다.
  Object.defineProperty(Car, "age", {
    // get과 set은 각각 접근자, 설정자로 사용할 수 있는 예약어다.
    // getter
    get: function () {
      return this.carAge;
    },
    set: function (value) {
      this.carAge = value;
    },
  });

  return Car;
})();
```

위처럼 클래스로 정의한 객체를 함수를 사용해서 동일하게 만들 수 있다.
