# 목차

- 3.1 [리액트의 모든 훅 파헤치기](#리액트의-모든-훅-파헤치기)

# 리액트의 모든 훅 파헤치기

## useState

함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

사용법

```tsx
import { useState } from "react";

const [state, setState] = useState(initialState);
```

### useState 내부 구조

```jsx
// useState의 내부 구조를 흉내 낸 코드
const MyReact = (function () {
  const global = {};
  let index = 0;

  function useState(initialState) {
    if (!global.states) {
      // 애플리케이션 전체의 states 배열을 초기화 한다.
      // 최초 접근이라면 빈 배열로 초기화한다.
      global.states = [];
    }

    // states 정보를 조회해서 현재 상태값이 있는지 확인하고,
    // 없다면 초기값으로 설정한다.
    const currentState = global.states[index] || initialState;
    // states의 값을 위에서 조회한 현재 값으로 업데이트한다.
    global.states[index] = currentState;

    // 즉시 실행 함수로 setter를 만든다.
    const setState = (function () {
      // 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에
      // 접근할 수 있도록 한다.
      let currentIndex = index;
      return function (value) {
        global.states[currentIndex] = value;
        // 컴포넌트를 렌더링한다. 실제로 컴포넌트를 렌더링하는 코드는 생략했다.
      };
    })();
    // useState를 쓸 때마다 index를 하나씩 추가한다. 이 index는 setState에서 사용된다.
    // 즉, 하나의 state마다 index가 할당돼 있어 그 index가 배열의 값(global.states)을
    // 가리키고 필요할 때마다 그 값을 가져오게 한다.
    index = index + 1;

    return [currentState, setState];
  }

  // 실제 useState를 사용하는 컴포넌트
  function Component() {
    const [Value, setValue] = useState(0);
    // ...
  }
})();
```

- 클로저를 활용하여 구현함

### 게으른 초기화

- 대부분 useState의 기본 값을 선언하기 위해 원시 값을 인수로 넣는 경우가 대부분이다.
- 원시 값 말고도 특정한 값을 넘기는 함수를 인수로 넣을 수도 있다.
  - 이를 게으른 초기화(lazy initialization)라고 한다.

```jsx
// 일반적인 useState 사용
// 바로 값을 집어넣는다.
const [count, setCount] = useState(11);

// 게으른 초기화
// 위 코드와의 차이점은 함수를 실행해 값을 반환한다는 것이다.
const [count, setCount] = useState(() => {
  return 11;
});
```
